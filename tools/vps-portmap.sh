#!/usr/bin/env bash
# ┌──────────────────────────────────────────────────────────────┐
# │  vps-portmap — VPS Port & Service Registry                   │
# │  Scans all ports, services, Nginx, Docker, SSL certs.        │
# │  Outputs a YAML file readable by AI and humans.              │
# │                                                              │
# │  Usage:                                                      │
# │    vps-portmap              # Scan and write registry        │
# │    vps-portmap --show       # Show current registry          │
# │    vps-portmap --check 8080 # Check if port is available     │
# │    vps-portmap --json       # Output JSON to stdout          │
# │    vps-portmap --conflicts  # Show only conflicts/warnings   │
# │    vps-portmap --fix        # Interactive conflict resolution │
# │                                                              │
# │  Output: /etc/vps-portmap.yaml                               │
# │  Install: cp tools/vps-portmap.sh /usr/local/bin/vps-portmap │
# └──────────────────────────────────────────────────────────────┘

set -euo pipefail

# ── Config ────────────────────────────────────────────────────
REGISTRY_FILE="/etc/vps-portmap.yaml"
VERSION="1.1.0"

# ── Colors ────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── Helpers ───────────────────────────────────────────────────
log_header()  { echo -e "\n${CYAN}━━━ $1 ━━━${NC}"; }
log_ok()      { echo -e "  ${GREEN}✓${NC} $1"; }
log_warn()    { echo -e "  ${YELLOW}⚠${NC} $1"; }
log_info()    { echo -e "  ${DIM}$1${NC}"; }
log_port()    { printf "  ${BOLD}%-6s${NC} %-15s %-20s %s\n" "$1" "$2" "$3" "$4"; }

# ── Root check ────────────────────────────────────────────────
if [ "$(id -u)" -ne 0 ]; then
    echo -e "${RED}Error: vps-portmap must be run as root${NC}"
    echo "  Usage: sudo vps-portmap"
    exit 1
fi

# ══════════════════════════════════════════════════════════════
# ── Mode: --show ──────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════
if [ "${1:-}" = "--show" ]; then
    if [ -f "$REGISTRY_FILE" ]; then
        cat "$REGISTRY_FILE"
    else
        echo "No registry found. Run 'vps-portmap' first to scan."
        exit 1
    fi
    exit 0
fi

# ══════════════════════════════════════════════════════════════
# ── Mode: --check PORT ────────────────────────────────────────
# ══════════════════════════════════════════════════════════════
if [ "${1:-}" = "--check" ]; then
    PORT="${2:-}"
    if [ -z "$PORT" ]; then
        echo "Usage: vps-portmap --check <port>"
        exit 1
    fi

    # Check via ss
    LISTENER=$(ss -tlnp 2>/dev/null | grep ":${PORT} " || true)
    if [ -n "$LISTENER" ]; then
        PROC=$(echo "$LISTENER" | grep -oP 'users:\(\("\K[^"]+' | head -1 || echo "unknown")
        BIND=$(echo "$LISTENER" | awk '{print $4}' | head -1 | sed "s/:${PORT}$//")
        echo -e "${RED}Port $PORT is IN USE${NC}"
        echo -e "  Process: ${BOLD}$PROC${NC}"
        echo -e "  Bind:    $BIND"
        exit 1
    else
        echo -e "${GREEN}Port $PORT is AVAILABLE${NC}"
        exit 0
    fi
fi

# ══════════════════════════════════════════════════════════════
# ── Full Scan ─────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════

echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BOLD}  vps-portmap v${VERSION} — VPS Port & Service Registry${NC}"
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

# ── 1. System Info ────────────────────────────────────────────
log_header "System Info"

HOSTNAME=$(hostname)
OS_VERSION=$(cat /etc/debian_version 2>/dev/null || echo "unknown")
OS_PRETTY=$(grep -oP '(?<=PRETTY_NAME=").*(?=")' /etc/os-release 2>/dev/null || echo "Debian $OS_VERSION")
PUBLIC_IP=$(curl -s --max-time 5 ifconfig.me 2>/dev/null || echo "unknown")
SCAN_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
UPTIME=$(uptime -p 2>/dev/null || echo "unknown")

log_ok "Hostname: $HOSTNAME"
log_ok "OS: $OS_PRETTY"
log_ok "Public IP: $PUBLIC_IP"
log_ok "Uptime: $UPTIME"

# ── Start building YAML ──────────────────────────────────────
YAML="# VPS Port Map — Auto-generated by vps-portmap v${VERSION}
# Last scan: ${SCAN_DATE}
# Host: ${HOSTNAME} (${PUBLIC_IP})
#
# This file is the single source of truth for all ports, services,
# and URLs on this VPS. Read by AI assistants to avoid conflicts.
# Regenerate: sudo vps-portmap

system:
  hostname: \"${HOSTNAME}\"
  public_ip: \"${PUBLIC_IP}\"
  os: \"${OS_PRETTY}\"
  debian_version: \"${OS_VERSION}\"
  scan_date: \"${SCAN_DATE}\"
  uptime: \"${UPTIME}\"
"

# ── 2. TCP Ports ──────────────────────────────────────────────
log_header "TCP Ports in Use"

YAML+="
ports:"

# Collect all listening ports
PORTS_DATA=""
while IFS= read -r line; do
    # Parse ss output: State  Recv-Q  Send-Q  Local Address:Port  ...  users:(("proc",pid,fd))
    BIND_ADDR=$(echo "$line" | awk '{print $4}')
    PORT_NUM=$(echo "$BIND_ADDR" | rev | cut -d: -f1 | rev)
    BIND_IP=$(echo "$BIND_ADDR" | rev | cut -d: -f2- | rev)

    # Get process name
    PROC_NAME=$(echo "$line" | grep -oP 'users:\(\("\K[^"]+' || echo "unknown")
    PID=$(echo "$line" | grep -oP 'pid=\K[0-9]+' | head -1 || echo "")

    # Skip if we already have this port (ss can show duplicates for v4/v6)
    if echo "$PORTS_DATA" | grep -q "^${PORT_NUM}|"; then
        continue
    fi

    PORTS_DATA+="${PORT_NUM}|${BIND_IP}|${PROC_NAME}|${PID}
"

    # Determine description
    DESC=""
    case "$PORT_NUM" in
        22)   DESC="SSH server" ;;
        25)   DESC="SMTP" ;;
        53)   DESC="DNS" ;;
        80)   DESC="Nginx HTTP" ;;
        443)  DESC="Nginx HTTPS" ;;
        3306) DESC="MySQL/MariaDB" ;;
        5432) DESC="PostgreSQL" ;;
        6379) DESC="Redis" ;;
        8000) DESC="App server (uvicorn)" ;;
        *)    DESC="" ;;
    esac

    # Try to find systemd service for this PID
    SERVICE_NAME=""
    if [ -n "$PID" ] && [ "$PID" != "" ]; then
        SERVICE_NAME=$(systemctl status "$PID" 2>/dev/null | head -1 | grep -oP '● \K[^.]+' || true)
    fi

    if [ -n "$SERVICE_NAME" ] && [ -z "$DESC" ]; then
        DESC="Service: $SERVICE_NAME"
    fi

    YAML+="
  - port: ${PORT_NUM}
    protocol: tcp
    process: \"${PROC_NAME}\"
    bind: \"${BIND_IP}\"
    pid: ${PID:-0}"

    [ -n "$SERVICE_NAME" ] && YAML+="
    service: \"${SERVICE_NAME}\""

    [ -n "$DESC" ] && YAML+="
    description: \"${DESC}\""

    # Terminal output
    log_port ":${PORT_NUM}" "${BIND_IP}" "${PROC_NAME}" "${DESC}"

done < <(ss -tlnp 2>/dev/null | tail -n +2 | sort -t: -k2 -n)

if [ -z "$PORTS_DATA" ]; then
    YAML+="
  []  # No listening ports found"
    log_warn "No listening TCP ports found"
fi

# ── 3. Systemd Services ──────────────────────────────────────
log_header "Systemd Services (web/app)"

YAML+="
services:"

FOUND_SERVICES=false

# Look for services that bind to network ports (web apps, APIs, etc.)
# Filter: active services with ExecStart containing common server commands
while IFS= read -r svc; do
    SVC_NAME=$(echo "$svc" | awk '{print $1}' | sed 's/\.service$//')

    # Get service details
    SVC_USER=$(systemctl show "$SVC_NAME" -p User --value 2>/dev/null || echo "root")
    SVC_DIR=$(systemctl show "$SVC_NAME" -p WorkingDirectory --value 2>/dev/null || echo "")
    SVC_EXEC=$(systemctl show "$SVC_NAME" -p ExecStart --value 2>/dev/null || echo "")
    SVC_STATE=$(systemctl show "$SVC_NAME" -p ActiveState --value 2>/dev/null || echo "unknown")
    SVC_ENV_FILE=$(systemctl show "$SVC_NAME" -p EnvironmentFile --value 2>/dev/null || echo "")

    # Skip known system services that are never web apps
    case "$SVC_NAME" in
        kmod-static-nodes|systemd-*|dbus*|cron*|rsyslog*|ssh*|logind*|\
        udev*|polkit*|accounts-daemon|network*|ModemManager|udisks*|\
        packagekit*|snapd*|thermald*|irqbalance*|lvm2*|multipathd*)
            continue
            ;;
    esac

    # Skip nginx/apache themselves (we handle them separately)
    if [[ "$SVC_NAME" == "nginx" ]] || [[ "$SVC_NAME" == "apache"* ]]; then
        continue
    fi

    # Skip system services — only keep app services
    # Check if ExecStart contains web server indicators
    # Use word boundaries to avoid false positives (e.g., "kmod-static-nodes" matching "node")
    if ! echo "$SVC_EXEC" | grep -qP '(?:^|/)(?:uvicorn|gunicorn|node|npm|python3?|flask|django|next|nginx|apache|caddy|serve|fastapi)\b|--host|--port|--bind'; then
        continue
    fi

    FOUND_SERVICES=true

    # Extract port from ExecStart
    SVC_PORT=$(echo "$SVC_EXEC" | grep -oP '(?<=--port\s)\d+|(?<=--port=)\d+|(?<=:)\d{4,5}(?=\s|$)' | head -1 || echo "")
    SVC_BIND=$(echo "$SVC_EXEC" | grep -oP '(?<=--host\s)\S+|(?<=--host=)\S+' | head -1 || echo "")

    # Try to determine app type
    SVC_TYPE="unknown"
    echo "$SVC_EXEC" | grep -qi "uvicorn" && SVC_TYPE="fastapi/uvicorn"
    echo "$SVC_EXEC" | grep -qi "gunicorn" && SVC_TYPE="gunicorn"
    echo "$SVC_EXEC" | grep -qiP '(?:^|/)(node|npm|next)\b' && SVC_TYPE="node.js"
    echo "$SVC_EXEC" | grep -qi "flask" && SVC_TYPE="flask"
    echo "$SVC_EXEC" | grep -qi "django" && SVC_TYPE="django"
    echo "$SVC_EXEC" | grep -qi "ollama" && SVC_TYPE="ollama"

    # Find matching Nginx config for this port
    NGINX_CONF=""
    PUBLIC_URL=""
    if [ -n "$SVC_PORT" ] && [ -d "/etc/nginx/sites-enabled" ]; then
        for nconf in /etc/nginx/sites-enabled/*; do
            [ -f "$nconf" ] || continue
            if grep -q "proxy_pass.*:${SVC_PORT}" "$nconf" 2>/dev/null; then
                NGINX_CONF="$nconf"
                PUBLIC_URL=$(grep -oP 'server_name\s+\K[^;]+' "$nconf" | head -1 || true)
                break
            fi
        done
    fi

    YAML+="
  - name: \"${SVC_NAME}\"
    status: \"${SVC_STATE}\"
    user: \"${SVC_USER}\"
    directory: \"${SVC_DIR}\"
    type: \"${SVC_TYPE}\""

    [ -n "$SVC_PORT" ] && YAML+="
    port: ${SVC_PORT}"

    [ -n "$SVC_BIND" ] && YAML+="
    bind: \"${SVC_BIND}\""

    [ -n "$SVC_PORT" ] && YAML+="
    url_local: \"http://${SVC_BIND:-127.0.0.1}:${SVC_PORT}\""

    [ -n "$PUBLIC_URL" ] && YAML+="
    url_public: \"https://${PUBLIC_URL}\""

    [ -n "$NGINX_CONF" ] && YAML+="
    nginx_config: \"${NGINX_CONF}\""

    [ -n "$SVC_ENV_FILE" ] && [ "$SVC_ENV_FILE" != "(null)" ] && YAML+="
    env_file: \"${SVC_ENV_FILE}\""

    # Terminal output
    log_ok "${SVC_NAME} [${SVC_STATE}] → :${SVC_PORT:-?} (${SVC_TYPE})"
    [ -n "$SVC_DIR" ] && log_info "  Dir: $SVC_DIR"
    [ -n "$PUBLIC_URL" ] && log_info "  URL: https://$PUBLIC_URL"

done < <(systemctl list-units --type=service --state=active --no-legend --no-pager 2>/dev/null)

if [ "$FOUND_SERVICES" = false ]; then
    YAML+="
  []  # No app services detected"
    log_info "No web/app services detected"
fi

# ── 4. Nginx Virtual Hosts ───────────────────────────────────
log_header "Nginx Virtual Hosts"

YAML+="
nginx:"

FOUND_NGINX=false

if [ -d "/etc/nginx/sites-enabled" ]; then
    for conf in /etc/nginx/sites-enabled/*; do
        [ -f "$conf" ] || continue
        FOUND_NGINX=true

        CONF_NAME=$(basename "$conf")
        SERVER_NAME=$(grep -oP 'server_name\s+\K[^;]+' "$conf" | head -1 || echo "")
        LISTEN=$(grep -oP 'listen\s+\K[^;]+' "$conf" | head -1 || echo "")
        PROXY_PASS=$(grep -oP 'proxy_pass\s+\K[^;]+' "$conf" | head -1 || echo "")
        SSL_CERT=$(grep -oP 'ssl_certificate\s+\K[^;]+' "$conf" | head -1 || echo "")
        HAS_SSL="false"
        [ -n "$SSL_CERT" ] && HAS_SSL="true"

        YAML+="
  - config: \"${conf}\"
    server_name: \"${SERVER_NAME}\"
    listen: \"${LISTEN}\"
    proxy_pass: \"${PROXY_PASS}\"
    ssl: ${HAS_SSL}"

        [ -n "$SSL_CERT" ] && YAML+="
    ssl_cert: \"${SSL_CERT}\""

        # Terminal output
        if [ "$HAS_SSL" = "true" ]; then
            log_ok "${CONF_NAME}: ${SERVER_NAME} → ${PROXY_PASS} [SSL]"
        else
            log_ok "${CONF_NAME}: ${SERVER_NAME} → ${PROXY_PASS}"
        fi
    done
fi

if [ "$FOUND_NGINX" = false ]; then
    YAML+="
  []  # No Nginx sites configured"
    log_info "No Nginx virtual hosts found"
fi

# ── 5. Docker Containers ─────────────────────────────────────
log_header "Docker Containers"

YAML+="
docker:"

if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
    FOUND_DOCKER=false

    while IFS= read -r line; do
        [ -z "$line" ] && continue
        FOUND_DOCKER=true

        C_NAME=$(echo "$line" | cut -d'|' -f1)
        C_IMAGE=$(echo "$line" | cut -d'|' -f2)
        C_PORTS=$(echo "$line" | cut -d'|' -f3)
        C_STATUS=$(echo "$line" | cut -d'|' -f4)

        YAML+="
  - container: \"${C_NAME}\"
    image: \"${C_IMAGE}\"
    ports: \"${C_PORTS}\"
    status: \"${C_STATUS}\""

        log_ok "${C_NAME}: ${C_IMAGE} → ${C_PORTS:-no ports}"
    done < <(docker ps --format '{{.Names}}|{{.Image}}|{{.Ports}}|{{.Status}}' 2>/dev/null)

    if [ "$FOUND_DOCKER" = false ]; then
        YAML+="
  []  # Docker running, no containers"
        log_info "Docker installed, no running containers"
    fi
else
    YAML+="
  []  # Docker not installed or not running"
    log_info "Docker not installed or not running"
fi

# ── 6. SSL Certificates ──────────────────────────────────────
log_header "SSL Certificates"

YAML+="
ssl_certificates:"

if command -v certbot &>/dev/null; then
    FOUND_CERTS=false

    # certbot certificates outputs blocks like:
    #   Certificate Name: domain.com
    #     Domains: domain.com www.domain.com
    #     Expiry Date: 2026-05-15 12:00:00+00:00 (VALID: 89 days)
    #     Certificate Path: /etc/letsencrypt/live/domain.com/fullchain.pem
    # We parse this block-by-block
    CERT_NAME="" CERT_DOMAINS="" CERT_EXPIRY_RAW="" CERT_CERT_PATH=""

    while IFS= read -r line; do
        # Extract Certificate Name
        if echo "$line" | grep -qP '^\s*Certificate Name:\s'; then
            # Save previous cert if any
            if [ -n "$CERT_NAME" ]; then
                FOUND_CERTS=true
                CERT_PATH="/etc/letsencrypt/live/${CERT_NAME}"
                # Try to get expiry from openssl if we have the file
                CERT_EXPIRY=""
                if [ -f "${CERT_PATH}/fullchain.pem" ]; then
                    CERT_EXPIRY=$(openssl x509 -enddate -noout -in "${CERT_PATH}/fullchain.pem" 2>/dev/null | sed 's/notAfter=//' || echo "")
                elif [ -n "$CERT_EXPIRY_RAW" ]; then
                    CERT_EXPIRY="$CERT_EXPIRY_RAW"
                fi
                YAML+="
  - domain: \"${CERT_NAME}\"
    domains: \"${CERT_DOMAINS}\"
    path: \"${CERT_PATH}\"
    expiry: \"${CERT_EXPIRY}\""
                log_ok "${CERT_NAME} → expires: ${CERT_EXPIRY:-unknown}"
            fi
            # Start new cert block
            CERT_NAME=$(echo "$line" | sed 's/.*Certificate Name:\s*//')
            CERT_DOMAINS="" CERT_EXPIRY_RAW="" CERT_CERT_PATH=""
        fi
        # Extract Domains
        if echo "$line" | grep -qP '^\s*Domains:\s'; then
            CERT_DOMAINS=$(echo "$line" | sed 's/.*Domains:\s*//')
        fi
        # Extract Expiry Date
        if echo "$line" | grep -qP '^\s*Expiry Date:\s'; then
            CERT_EXPIRY_RAW=$(echo "$line" | sed 's/.*Expiry Date:\s*//' | sed 's/\s*(VALID.*//' | sed 's/\s*(INVALID.*//')
        fi
    done < <(certbot certificates 2>/dev/null)

    # Flush last cert
    if [ -n "$CERT_NAME" ]; then
        FOUND_CERTS=true
        CERT_PATH="/etc/letsencrypt/live/${CERT_NAME}"
        CERT_EXPIRY=""
        if [ -f "${CERT_PATH}/fullchain.pem" ]; then
            CERT_EXPIRY=$(openssl x509 -enddate -noout -in "${CERT_PATH}/fullchain.pem" 2>/dev/null | sed 's/notAfter=//' || echo "")
        elif [ -n "$CERT_EXPIRY_RAW" ]; then
            CERT_EXPIRY="$CERT_EXPIRY_RAW"
        fi
        YAML+="
  - domain: \"${CERT_NAME}\"
    domains: \"${CERT_DOMAINS}\"
    path: \"${CERT_PATH}\"
    expiry: \"${CERT_EXPIRY}\""
        log_ok "${CERT_NAME} → expires: ${CERT_EXPIRY:-unknown}"
    fi

    if [ "$FOUND_CERTS" = false ]; then
        YAML+="
  []  # Certbot installed, no certificates"
        log_info "Certbot installed, no certificates found"
    fi
else
    YAML+="
  []  # Certbot not installed"
    log_info "Certbot not installed"
fi

# ── 7. Cactus Flasher Board Ports ────────────────────────────
log_header "Cactus Flasher Board Ports"

YAML+="
board_ports:"

# Try to find boards.yaml from cactus-flasher service
CF_DIR=$(systemctl show cactus-flasher -p WorkingDirectory --value 2>/dev/null || echo "")
BOARDS_FILE=""
[ -n "$CF_DIR" ] && [ -f "${CF_DIR}/config/boards.yaml" ] && BOARDS_FILE="${CF_DIR}/config/boards.yaml"

if [ -n "$BOARDS_FILE" ]; then
    YAML+="
  source: \"${BOARDS_FILE}\"
  reserved_ranges:
    webserver: \"8001-8099\"
    ota: \"8201-8299\"
    native_api: \"6001-6099\"
  boards:"

    # Parse boards.yaml — extract board names and IDs
    FOUND_BOARDS=false
    CURRENT_BOARD=""
    while IFS= read -r line; do
        # Match board name (indented key under boards:)
        if echo "$line" | grep -qP '^\s{2}\S+:$'; then
            CURRENT_BOARD=$(echo "$line" | sed 's/://;s/^[[:space:]]*//')
        fi
        # Match id field
        if [ -n "$CURRENT_BOARD" ] && echo "$line" | grep -qP '^\s+id:\s+\d+'; then
            BOARD_ID=$(echo "$line" | grep -oP '\d+')
            FOUND_BOARDS=true

            WEB_PORT=$((8000 + BOARD_ID))
            OTA_PORT=$((8200 + BOARD_ID))
            API_PORT=$((6000 + BOARD_ID))

            YAML+="
    - name: \"${CURRENT_BOARD}\"
      id: ${BOARD_ID}
      webserver: ${WEB_PORT}
      ota: ${OTA_PORT}
      api: ${API_PORT}"

            log_ok "${CURRENT_BOARD} [ID:${BOARD_ID}] → web:${WEB_PORT} ota:${OTA_PORT} api:${API_PORT}"
            CURRENT_BOARD=""
        fi
    done < "$BOARDS_FILE"

    if [ "$FOUND_BOARDS" = false ]; then
        YAML+="
    []  # No boards registered"
        log_info "No boards in boards.yaml"
    fi
else
    YAML+="
  source: null  # Cactus Flasher not found
  reserved_ranges:
    webserver: \"8001-8099\"
    ota: \"8201-8299\"
    native_api: \"6001-6099\"
  boards: []"
    log_info "Cactus Flasher not detected (no boards.yaml)"
fi

# ── 8. Conflicts Detection ───────────────────────────────────
log_header "Conflict Check"

YAML+="
conflicts:"

CONFLICTS_FOUND=false

# Check for duplicate ports
SORTED_PORTS=$(echo "$PORTS_DATA" | grep -v '^$' | cut -d'|' -f1 | sort -n)
DUPES=$(echo "$SORTED_PORTS" | uniq -d)
if [ -n "$DUPES" ]; then
    CONFLICTS_FOUND=true
    for dp in $DUPES; do
        PROCS=$(echo "$PORTS_DATA" | grep "^${dp}|" | cut -d'|' -f3 | tr '\n' ', ' | sed 's/,$//')
        YAML+="
  - type: \"duplicate_port\"
    port: ${dp}
    processes: \"${PROCS}\"
    severity: \"high\""
        log_warn "Port :${dp} used by multiple processes: ${PROCS}"
    done
fi

# Check for Nginx configs pointing to same backend
if [ -d "/etc/nginx/sites-enabled" ]; then
    PROXY_TARGETS=""
    for conf in /etc/nginx/sites-enabled/*; do
        [ -f "$conf" ] || continue
        PP=$(grep -oP 'proxy_pass\s+\K[^;]+' "$conf" | head -1 || true)
        [ -n "$PP" ] && PROXY_TARGETS+="$(basename "$conf")|${PP}\n"
    done
    DUPE_TARGETS=$(echo -e "$PROXY_TARGETS" | grep -v '^$' | cut -d'|' -f2 | sort | uniq -d)
    for dt in $DUPE_TARGETS; do
        [ -z "$dt" ] && continue
        CONFLICTS_FOUND=true
        CONFIGS=$(echo -e "$PROXY_TARGETS" | grep "|${dt}" | cut -d'|' -f1 | tr '\n' ', ' | sed 's/,$//')
        YAML+="
  - type: \"duplicate_proxy\"
    target: \"${dt}\"
    configs: \"${CONFIGS}\"
    severity: \"medium\""
        log_warn "Multiple Nginx configs proxy to ${dt}: ${CONFIGS}"
    done
fi

if [ "$CONFLICTS_FOUND" = false ]; then
    YAML+="
  []  # No conflicts detected"
    log_ok "No conflicts detected"
fi

# ── 9. Available Port Ranges ─────────────────────────────────
log_header "Available Port Ranges"

YAML+="
available_ports:"

# Collect all used ports into a set
USED_PORTS=$(echo "$PORTS_DATA" | grep -v '^$' | cut -d'|' -f1 | sort -nu)

# Check common ranges
check_range() {
    local START=$1 END=$2 NOTE=$3
    local AVAILABLE=true
    for p in $(seq "$START" "$END"); do
        if echo "$USED_PORTS" | grep -q "^${p}$"; then
            AVAILABLE=false
            break
        fi
    done
    if [ "$AVAILABLE" = true ]; then
        YAML+="
  - range: \"${START}-${END}\"
    note: \"${NOTE}\""
        log_ok "${START}-${END}: ${NOTE}"
    fi
}

check_range 3000 3009 "Node.js/React dev servers"
check_range 5000 5009 "Flask/general purpose"
check_range 8100 8199 "Free (between board webserver and OTA ranges)"
check_range 9000 9009 "General purpose app servers"
check_range 9090 9099 "Monitoring/admin tools"

# ── Write file ────────────────────────────────────────────────
echo "$YAML" > "$REGISTRY_FILE"
chmod 644 "$REGISTRY_FILE"

# ── Summary ───────────────────────────────────────────────────
echo ""
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${GREEN}${BOLD}  ✓ Registry saved to ${REGISTRY_FILE}${NC}"
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""
echo -e "  ${BOLD}Quick commands:${NC}"
echo -e "    ${CYAN}vps-portmap --show${NC}       View current registry"
echo -e "    ${CYAN}vps-portmap --check 8080${NC} Check if port is free"
echo -e "    ${CYAN}vps-portmap --fix${NC}        Fix detected conflicts"
echo -e "    ${CYAN}cat ${REGISTRY_FILE}${NC}     Read raw YAML"
echo ""

# ── Mode: --json output ──────────────────────────────────────
if [ "${1:-}" = "--json" ]; then
    # Simple YAML-to-JSON conversion using Python (available on all Debian)
    python3 -c "
import yaml, json, sys
with open('$REGISTRY_FILE') as f:
    data = yaml.safe_load(f)
print(json.dumps(data, indent=2, default=str))
" 2>/dev/null || echo "Error: python3 + pyyaml needed for JSON output"
fi

# ── Mode: --conflicts only ────────────────────────────────────
if [ "${1:-}" = "--conflicts" ]; then
    if [ "$CONFLICTS_FOUND" = true ]; then
        echo -e "\n${RED}${BOLD}Conflicts found!${NC}"
        # Re-display conflicts
        grep -A3 "type:" "$REGISTRY_FILE" | head -20
        exit 1
    else
        echo -e "\n${GREEN}No conflicts.${NC}"
        exit 0
    fi
fi

# ══════════════════════════════════════════════════════════════
# ── Mode: --fix (Interactive Conflict Resolution) ────────────
# ══════════════════════════════════════════════════════════════
if [ "${1:-}" = "--fix" ]; then
    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}  vps-portmap --fix — Interactive Conflict Resolution${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    FIX_COUNT=0

    # ── Fix 1: Duplicate Nginx proxy targets ──────────────────
    if [ -d "/etc/nginx/sites-enabled" ]; then
        PROXY_TARGETS_FIX=""
        for conf in /etc/nginx/sites-enabled/*; do
            [ -f "$conf" ] || continue
            PP=$(grep -oP 'proxy_pass\s+\K[^;]+' "$conf" | head -1 || true)
            [ -n "$PP" ] && PROXY_TARGETS_FIX+="$(basename "$conf")|${PP}|${conf}\n"
        done
        DUPE_TARGETS_FIX=$(echo -e "$PROXY_TARGETS_FIX" | grep -v '^$' | cut -d'|' -f2 | sort | uniq -d)
        for dt in $DUPE_TARGETS_FIX; do
            [ -z "$dt" ] && continue
            echo ""
            log_warn "Multiple Nginx configs proxy to the same target: ${BOLD}${dt}${NC}"
            echo ""
            CONFLICTING_CONFIGS=()
            while IFS= read -r entry; do
                [ -z "$entry" ] && continue
                C_NAME=$(echo "$entry" | cut -d'|' -f1)
                C_PATH=$(echo "$entry" | cut -d'|' -f3)
                C_DOMAIN=$(grep -oP 'server_name\s+\K[^;]+' "$C_PATH" 2>/dev/null | head -1 || echo "(none)")
                CONFLICTING_CONFIGS+=("$C_PATH")
                echo -e "    ${BOLD}$((${#CONFLICTING_CONFIGS[@]}))${NC}. ${C_NAME} (domain: ${C_DOMAIN}) → ${dt}"
            done < <(echo -e "$PROXY_TARGETS_FIX" | grep "|${dt}")

            if [ ${#CONFLICTING_CONFIGS[@]} -ge 2 ]; then
                echo ""
                echo -e "  ${YELLOW}Choose action:${NC}"
                echo -e "    ${BOLD}d${NC}) Disable one of the configs (moves to sites-available)"
                echo -e "    ${BOLD}s${NC}) Skip this conflict"
                read -rp "  > " FIX_ACTION
                case "$FIX_ACTION" in
                    d|D)
                        echo ""
                        echo -e "  Which config to disable? (enter number)"
                        for i in "${!CONFLICTING_CONFIGS[@]}"; do
                            echo -e "    ${BOLD}$((i+1))${NC}) $(basename "${CONFLICTING_CONFIGS[$i]}")"
                        done
                        read -rp "  > " DISABLE_NUM
                        DISABLE_IDX=$((DISABLE_NUM - 1))
                        if [ "$DISABLE_IDX" -ge 0 ] && [ "$DISABLE_IDX" -lt ${#CONFLICTING_CONFIGS[@]} ]; then
                            DISABLE_PATH="${CONFLICTING_CONFIGS[$DISABLE_IDX]}"
                            DISABLE_NAME=$(basename "$DISABLE_PATH")
                            AVAIL_PATH="/etc/nginx/sites-available/${DISABLE_NAME}"
                            echo -e "  Disabling ${BOLD}${DISABLE_NAME}${NC}..."
                            # Move symlink target or file to sites-available, remove from sites-enabled
                            if [ -L "$DISABLE_PATH" ]; then
                                rm "$DISABLE_PATH"
                                log_ok "Removed symlink: ${DISABLE_PATH}"
                            else
                                mv "$DISABLE_PATH" "$AVAIL_PATH"
                                log_ok "Moved to: ${AVAIL_PATH}"
                            fi
                            FIX_COUNT=$((FIX_COUNT + 1))
                        else
                            log_warn "Invalid selection, skipping."
                        fi
                        ;;
                    *)
                        log_info "Skipped."
                        ;;
                esac
            fi
        done
    fi

    # ── Fix 2: Nginx configs with invalid/non-FQDN domains ───
    if [ -d "/etc/nginx/sites-enabled" ]; then
        for conf in /etc/nginx/sites-enabled/*; do
            [ -f "$conf" ] || continue
            CONF_NAME=$(basename "$conf")
            SN=$(grep -oP 'server_name\s+\K[^;]+' "$conf" | head -1 || echo "")
            # Check if server_name looks like a bare word (no dots = not a FQDN)
            if [ -n "$SN" ] && ! echo "$SN" | grep -q '\.'; then
                echo ""
                log_warn "Nginx config ${BOLD}${CONF_NAME}${NC} has non-FQDN server_name: ${BOLD}${SN}${NC}"
                echo -e "  ${YELLOW}Choose action:${NC}"
                echo -e "    ${BOLD}r${NC}) Replace with a valid domain"
                echo -e "    ${BOLD}d${NC}) Disable this config"
                echo -e "    ${BOLD}s${NC}) Skip"
                read -rp "  > " FIX_ACTION
                case "$FIX_ACTION" in
                    r|R)
                        read -rp "  Enter the correct FQDN (e.g., app.example.com): " NEW_DOMAIN
                        if echo "$NEW_DOMAIN" | grep -qP '^[a-zA-Z0-9]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}$'; then
                            sed -i "s/server_name ${SN};/server_name ${NEW_DOMAIN};/" "$conf"
                            log_ok "Updated server_name to: ${NEW_DOMAIN}"
                            FIX_COUNT=$((FIX_COUNT + 1))
                            # Offer to fix SSL cert too
                            if grep -q "ssl_certificate" "$conf"; then
                                echo -e "  ${YELLOW}This config has SSL paths. Update cert paths for ${NEW_DOMAIN}?${NC}"
                                echo -e "    ${BOLD}y${NC}) Yes, update paths to /etc/letsencrypt/live/${NEW_DOMAIN}/"
                                echo -e "    ${BOLD}c${NC}) Yes, and run certbot to obtain cert"
                                echo -e "    ${BOLD}n${NC}) No, leave as is"
                                read -rp "  > " SSL_ACTION
                                case "$SSL_ACTION" in
                                    y|Y)
                                        sed -i "s|ssl_certificate .*|ssl_certificate /etc/letsencrypt/live/${NEW_DOMAIN}/fullchain.pem;|" "$conf"
                                        sed -i "s|ssl_certificate_key .*|ssl_certificate_key /etc/letsencrypt/live/${NEW_DOMAIN}/privkey.pem;|" "$conf"
                                        log_ok "Updated SSL paths for ${NEW_DOMAIN}"
                                        FIX_COUNT=$((FIX_COUNT + 1))
                                        ;;
                                    c|C)
                                        echo -e "  Running certbot for ${NEW_DOMAIN}..."
                                        if certbot --nginx -d "$NEW_DOMAIN" --non-interactive --agree-tos --redirect 2>&1; then
                                            log_ok "Certbot completed for ${NEW_DOMAIN}"
                                            FIX_COUNT=$((FIX_COUNT + 1))
                                        else
                                            log_warn "Certbot failed. You may need to run it manually."
                                        fi
                                        ;;
                                    *)
                                        log_info "SSL paths unchanged."
                                        ;;
                                esac
                            fi
                        else
                            log_warn "Invalid domain format. Must be like: app.example.com"
                        fi
                        ;;
                    d|D)
                        AVAIL_PATH="/etc/nginx/sites-available/${CONF_NAME}"
                        if [ -L "$conf" ]; then
                            rm "$conf"
                            log_ok "Removed symlink: ${conf}"
                        else
                            mv "$conf" "$AVAIL_PATH"
                            log_ok "Moved to: ${AVAIL_PATH}"
                        fi
                        FIX_COUNT=$((FIX_COUNT + 1))
                        ;;
                    *)
                        log_info "Skipped."
                        ;;
                esac
            fi
        done
    fi

    # ── Fix 3: Stale Docker containers (running, no ports) ────
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        while IFS= read -r line; do
            [ -z "$line" ] && continue
            C_NAME=$(echo "$line" | cut -d'|' -f1)
            C_PORTS=$(echo "$line" | cut -d'|' -f2)
            C_STATUS=$(echo "$line" | cut -d'|' -f3)
            C_IMAGE=$(echo "$line" | cut -d'|' -f4)

            # Flag containers with no port bindings that might be stale
            if [ -z "$C_PORTS" ]; then
                echo ""
                log_warn "Docker container ${BOLD}${C_NAME}${NC} (${C_IMAGE}) has no port bindings"
                echo -e "    Status: ${C_STATUS}"
                echo -e "  ${YELLOW}Choose action:${NC}"
                echo -e "    ${BOLD}r${NC}) Remove container (docker rm -f)"
                echo -e "    ${BOLD}s${NC}) Skip"
                read -rp "  > " FIX_ACTION
                case "$FIX_ACTION" in
                    r|R)
                        docker rm -f "$C_NAME" &>/dev/null
                        log_ok "Removed container: ${C_NAME}"
                        FIX_COUNT=$((FIX_COUNT + 1))
                        ;;
                    *)
                        log_info "Skipped."
                        ;;
                esac
            fi
        done < <(docker ps --format '{{.Names}}|{{.Ports}}|{{.Status}}|{{.Image}}' 2>/dev/null)
    fi

    # ── Fix 4: Nginx reload if changes were made ──────────────
    echo ""
    if [ "$FIX_COUNT" -gt 0 ]; then
        echo -e "${GREEN}${BOLD}  $FIX_COUNT fix(es) applied.${NC}"

        # Test and reload Nginx if it's running
        if systemctl is-active --quiet nginx 2>/dev/null; then
            echo ""
            echo -e "  ${YELLOW}Test and reload Nginx?${NC}"
            echo -e "    ${BOLD}y${NC}) Yes"
            echo -e "    ${BOLD}n${NC}) No"
            read -rp "  > " RELOAD_ACTION
            case "$RELOAD_ACTION" in
                y|Y)
                    if nginx -t 2>&1; then
                        systemctl reload nginx
                        log_ok "Nginx reloaded successfully"
                    else
                        log_warn "Nginx config test failed! Fix errors before reloading."
                    fi
                    ;;
                *)
                    log_info "Nginx not reloaded. Run 'nginx -t && systemctl reload nginx' when ready."
                    ;;
            esac
        fi

        # Re-scan to update registry
        echo ""
        echo -e "  ${YELLOW}Re-scan to update registry?${NC}"
        echo -e "    ${BOLD}y${NC}) Yes"
        echo -e "    ${BOLD}n${NC}) No"
        read -rp "  > " RESCAN_ACTION
        case "$RESCAN_ACTION" in
            y|Y)
                echo -e "\n  Re-scanning..."
                exec "$0"
                ;;
            *)
                log_info "Run 'vps-portmap' to update the registry."
                ;;
        esac
    else
        echo -e "${GREEN}  No fixes needed or all conflicts skipped.${NC}"
    fi

    exit 0
fi
