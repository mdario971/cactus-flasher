#!/usr/bin/env bash
# ┌──────────────────────────────────────────────────────────────┐
# │  vps-portmap — VPS Port & Service Registry                   │
# │  Scans all ports, services, Nginx, Docker, SSL certs.        │
# │  Outputs a YAML file readable by AI and humans.              │
# │                                                              │
# │  Usage:                                                      │
# │    vps-portmap              # Scan and write registry        │
# │    vps-portmap --show       # Show current registry          │
# │    vps-portmap --check 8080 # Check if port is available     │
# │    vps-portmap --json       # Output JSON to stdout          │
# │    vps-portmap --conflicts  # Show only conflicts/warnings   │
# │                                                              │
# │  Output: /etc/vps-portmap.yaml                               │
# │  Install: cp tools/vps-portmap.sh /usr/local/bin/vps-portmap │
# └──────────────────────────────────────────────────────────────┘

set -euo pipefail

# ── Config ────────────────────────────────────────────────────
REGISTRY_FILE="/etc/vps-portmap.yaml"
VERSION="1.0.0"

# ── Colors ────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── Helpers ───────────────────────────────────────────────────
log_header()  { echo -e "\n${CYAN}━━━ $1 ━━━${NC}"; }
log_ok()      { echo -e "  ${GREEN}✓${NC} $1"; }
log_warn()    { echo -e "  ${YELLOW}⚠${NC} $1"; }
log_info()    { echo -e "  ${DIM}$1${NC}"; }
log_port()    { printf "  ${BOLD}%-6s${NC} %-15s %-20s %s\n" "$1" "$2" "$3" "$4"; }

# ── Root check ────────────────────────────────────────────────
if [ "$(id -u)" -ne 0 ]; then
    echo -e "${RED}Error: vps-portmap must be run as root${NC}"
    echo "  Usage: sudo vps-portmap"
    exit 1
fi

# ══════════════════════════════════════════════════════════════
# ── Mode: --show ──────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════
if [ "${1:-}" = "--show" ]; then
    if [ -f "$REGISTRY_FILE" ]; then
        cat "$REGISTRY_FILE"
    else
        echo "No registry found. Run 'vps-portmap' first to scan."
        exit 1
    fi
    exit 0
fi

# ══════════════════════════════════════════════════════════════
# ── Mode: --check PORT ────────────────────────────────────────
# ══════════════════════════════════════════════════════════════
if [ "${1:-}" = "--check" ]; then
    PORT="${2:-}"
    if [ -z "$PORT" ]; then
        echo "Usage: vps-portmap --check <port>"
        exit 1
    fi

    # Check via ss
    LISTENER=$(ss -tlnp 2>/dev/null | grep ":${PORT} " || true)
    if [ -n "$LISTENER" ]; then
        PROC=$(echo "$LISTENER" | grep -oP 'users:\(\("\K[^"]+' | head -1 || echo "unknown")
        BIND=$(echo "$LISTENER" | awk '{print $4}' | head -1 | sed "s/:${PORT}$//")
        echo -e "${RED}Port $PORT is IN USE${NC}"
        echo -e "  Process: ${BOLD}$PROC${NC}"
        echo -e "  Bind:    $BIND"
        exit 1
    else
        echo -e "${GREEN}Port $PORT is AVAILABLE${NC}"
        exit 0
    fi
fi

# ══════════════════════════════════════════════════════════════
# ── Full Scan ─────────────────────────────────────────────────
# ══════════════════════════════════════════════════════════════

echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BOLD}  vps-portmap v${VERSION} — VPS Port & Service Registry${NC}"
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

# ── 1. System Info ────────────────────────────────────────────
log_header "System Info"

HOSTNAME=$(hostname)
OS_VERSION=$(cat /etc/debian_version 2>/dev/null || echo "unknown")
OS_PRETTY=$(grep -oP '(?<=PRETTY_NAME=").*(?=")' /etc/os-release 2>/dev/null || echo "Debian $OS_VERSION")
PUBLIC_IP=$(curl -s --max-time 5 ifconfig.me 2>/dev/null || echo "unknown")
SCAN_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
UPTIME=$(uptime -p 2>/dev/null || echo "unknown")

log_ok "Hostname: $HOSTNAME"
log_ok "OS: $OS_PRETTY"
log_ok "Public IP: $PUBLIC_IP"
log_ok "Uptime: $UPTIME"

# ── Start building YAML ──────────────────────────────────────
YAML="# VPS Port Map — Auto-generated by vps-portmap v${VERSION}
# Last scan: ${SCAN_DATE}
# Host: ${HOSTNAME} (${PUBLIC_IP})
#
# This file is the single source of truth for all ports, services,
# and URLs on this VPS. Read by AI assistants to avoid conflicts.
# Regenerate: sudo vps-portmap

system:
  hostname: \"${HOSTNAME}\"
  public_ip: \"${PUBLIC_IP}\"
  os: \"${OS_PRETTY}\"
  debian_version: \"${OS_VERSION}\"
  scan_date: \"${SCAN_DATE}\"
  uptime: \"${UPTIME}\"
"

# ── 2. TCP Ports ──────────────────────────────────────────────
log_header "TCP Ports in Use"

YAML+="
ports:"

# Collect all listening ports
PORTS_DATA=""
while IFS= read -r line; do
    # Parse ss output: State  Recv-Q  Send-Q  Local Address:Port  ...  users:(("proc",pid,fd))
    BIND_ADDR=$(echo "$line" | awk '{print $4}')
    PORT_NUM=$(echo "$BIND_ADDR" | rev | cut -d: -f1 | rev)
    BIND_IP=$(echo "$BIND_ADDR" | rev | cut -d: -f2- | rev)

    # Get process name
    PROC_NAME=$(echo "$line" | grep -oP 'users:\(\("\K[^"]+' || echo "unknown")
    PID=$(echo "$line" | grep -oP 'pid=\K[0-9]+' | head -1 || echo "")

    # Skip if we already have this port (ss can show duplicates for v4/v6)
    if echo "$PORTS_DATA" | grep -q "^${PORT_NUM}|"; then
        continue
    fi

    PORTS_DATA+="${PORT_NUM}|${BIND_IP}|${PROC_NAME}|${PID}
"

    # Determine description
    DESC=""
    case "$PORT_NUM" in
        22)   DESC="SSH server" ;;
        25)   DESC="SMTP" ;;
        53)   DESC="DNS" ;;
        80)   DESC="Nginx HTTP" ;;
        443)  DESC="Nginx HTTPS" ;;
        3306) DESC="MySQL/MariaDB" ;;
        5432) DESC="PostgreSQL" ;;
        6379) DESC="Redis" ;;
        8000) DESC="App server (uvicorn)" ;;
        *)    DESC="" ;;
    esac

    # Try to find systemd service for this PID
    SERVICE_NAME=""
    if [ -n "$PID" ] && [ "$PID" != "" ]; then
        SERVICE_NAME=$(systemctl status "$PID" 2>/dev/null | head -1 | grep -oP '● \K[^.]+' || true)
    fi

    if [ -n "$SERVICE_NAME" ] && [ -z "$DESC" ]; then
        DESC="Service: $SERVICE_NAME"
    fi

    YAML+="
  - port: ${PORT_NUM}
    protocol: tcp
    process: \"${PROC_NAME}\"
    bind: \"${BIND_IP}\"
    pid: ${PID:-0}"

    [ -n "$SERVICE_NAME" ] && YAML+="
    service: \"${SERVICE_NAME}\""

    [ -n "$DESC" ] && YAML+="
    description: \"${DESC}\""

    # Terminal output
    log_port ":${PORT_NUM}" "${BIND_IP}" "${PROC_NAME}" "${DESC}"

done < <(ss -tlnp 2>/dev/null | tail -n +2 | sort -t: -k2 -n)

if [ -z "$PORTS_DATA" ]; then
    YAML+="
  []  # No listening ports found"
    log_warn "No listening TCP ports found"
fi

# ── 3. Systemd Services ──────────────────────────────────────
log_header "Systemd Services (web/app)"

YAML+="
services:"

FOUND_SERVICES=false

# Look for services that bind to network ports (web apps, APIs, etc.)
# Filter: active services with ExecStart containing common server commands
while IFS= read -r svc; do
    SVC_NAME=$(echo "$svc" | awk '{print $1}' | sed 's/\.service$//')

    # Get service details
    SVC_USER=$(systemctl show "$SVC_NAME" -p User --value 2>/dev/null || echo "root")
    SVC_DIR=$(systemctl show "$SVC_NAME" -p WorkingDirectory --value 2>/dev/null || echo "")
    SVC_EXEC=$(systemctl show "$SVC_NAME" -p ExecStart --value 2>/dev/null || echo "")
    SVC_STATE=$(systemctl show "$SVC_NAME" -p ActiveState --value 2>/dev/null || echo "unknown")
    SVC_ENV_FILE=$(systemctl show "$SVC_NAME" -p EnvironmentFile --value 2>/dev/null || echo "")

    # Skip system services — only keep app services
    # Check if ExecStart contains web server indicators
    if ! echo "$SVC_EXEC" | grep -qiE 'uvicorn|gunicorn|node|npm|python|flask|django|next|nginx|apache|caddy|http|serve|fastapi'; then
        continue
    fi

    # Skip nginx/apache themselves (we handle them separately)
    if [[ "$SVC_NAME" == "nginx" ]] || [[ "$SVC_NAME" == "apache"* ]]; then
        continue
    fi

    FOUND_SERVICES=true

    # Extract port from ExecStart
    SVC_PORT=$(echo "$SVC_EXEC" | grep -oP '(?<=--port\s)\d+|(?<=--port=)\d+|(?<=:)\d{4,5}(?=\s|$)' | head -1 || echo "")
    SVC_BIND=$(echo "$SVC_EXEC" | grep -oP '(?<=--host\s)\S+|(?<=--host=)\S+' | head -1 || echo "")

    # Try to determine app type
    SVC_TYPE="unknown"
    echo "$SVC_EXEC" | grep -qi "uvicorn" && SVC_TYPE="fastapi/uvicorn"
    echo "$SVC_EXEC" | grep -qi "gunicorn" && SVC_TYPE="gunicorn"
    echo "$SVC_EXEC" | grep -qi "node\|npm\|next" && SVC_TYPE="node.js"
    echo "$SVC_EXEC" | grep -qi "flask" && SVC_TYPE="flask"
    echo "$SVC_EXEC" | grep -qi "django" && SVC_TYPE="django"

    # Find matching Nginx config for this port
    NGINX_CONF=""
    PUBLIC_URL=""
    if [ -n "$SVC_PORT" ] && [ -d "/etc/nginx/sites-enabled" ]; then
        for nconf in /etc/nginx/sites-enabled/*; do
            [ -f "$nconf" ] || continue
            if grep -q "proxy_pass.*:${SVC_PORT}" "$nconf" 2>/dev/null; then
                NGINX_CONF="$nconf"
                PUBLIC_URL=$(grep -oP 'server_name\s+\K[^;]+' "$nconf" | head -1 || true)
                break
            fi
        done
    fi

    YAML+="
  - name: \"${SVC_NAME}\"
    status: \"${SVC_STATE}\"
    user: \"${SVC_USER}\"
    directory: \"${SVC_DIR}\"
    type: \"${SVC_TYPE}\""

    [ -n "$SVC_PORT" ] && YAML+="
    port: ${SVC_PORT}"

    [ -n "$SVC_BIND" ] && YAML+="
    bind: \"${SVC_BIND}\""

    [ -n "$SVC_PORT" ] && YAML+="
    url_local: \"http://${SVC_BIND:-127.0.0.1}:${SVC_PORT}\""

    [ -n "$PUBLIC_URL" ] && YAML+="
    url_public: \"https://${PUBLIC_URL}\""

    [ -n "$NGINX_CONF" ] && YAML+="
    nginx_config: \"${NGINX_CONF}\""

    [ -n "$SVC_ENV_FILE" ] && [ "$SVC_ENV_FILE" != "(null)" ] && YAML+="
    env_file: \"${SVC_ENV_FILE}\""

    # Terminal output
    log_ok "${SVC_NAME} [${SVC_STATE}] → :${SVC_PORT:-?} (${SVC_TYPE})"
    [ -n "$SVC_DIR" ] && log_info "  Dir: $SVC_DIR"
    [ -n "$PUBLIC_URL" ] && log_info "  URL: https://$PUBLIC_URL"

done < <(systemctl list-units --type=service --state=active --no-legend --no-pager 2>/dev/null)

if [ "$FOUND_SERVICES" = false ]; then
    YAML+="
  []  # No app services detected"
    log_info "No web/app services detected"
fi

# ── 4. Nginx Virtual Hosts ───────────────────────────────────
log_header "Nginx Virtual Hosts"

YAML+="
nginx:"

FOUND_NGINX=false

if [ -d "/etc/nginx/sites-enabled" ]; then
    for conf in /etc/nginx/sites-enabled/*; do
        [ -f "$conf" ] || continue
        FOUND_NGINX=true

        CONF_NAME=$(basename "$conf")
        SERVER_NAME=$(grep -oP 'server_name\s+\K[^;]+' "$conf" | head -1 || echo "")
        LISTEN=$(grep -oP 'listen\s+\K[^;]+' "$conf" | head -1 || echo "")
        PROXY_PASS=$(grep -oP 'proxy_pass\s+\K[^;]+' "$conf" | head -1 || echo "")
        SSL_CERT=$(grep -oP 'ssl_certificate\s+\K[^;]+' "$conf" | head -1 || echo "")
        HAS_SSL="false"
        [ -n "$SSL_CERT" ] && HAS_SSL="true"

        YAML+="
  - config: \"${conf}\"
    server_name: \"${SERVER_NAME}\"
    listen: \"${LISTEN}\"
    proxy_pass: \"${PROXY_PASS}\"
    ssl: ${HAS_SSL}"

        [ -n "$SSL_CERT" ] && YAML+="
    ssl_cert: \"${SSL_CERT}\""

        # Terminal output
        if [ "$HAS_SSL" = "true" ]; then
            log_ok "${CONF_NAME}: ${SERVER_NAME} → ${PROXY_PASS} [SSL]"
        else
            log_ok "${CONF_NAME}: ${SERVER_NAME} → ${PROXY_PASS}"
        fi
    done
fi

if [ "$FOUND_NGINX" = false ]; then
    YAML+="
  []  # No Nginx sites configured"
    log_info "No Nginx virtual hosts found"
fi

# ── 5. Docker Containers ─────────────────────────────────────
log_header "Docker Containers"

YAML+="
docker:"

if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
    FOUND_DOCKER=false

    while IFS= read -r line; do
        [ -z "$line" ] && continue
        FOUND_DOCKER=true

        C_NAME=$(echo "$line" | cut -d'|' -f1)
        C_IMAGE=$(echo "$line" | cut -d'|' -f2)
        C_PORTS=$(echo "$line" | cut -d'|' -f3)
        C_STATUS=$(echo "$line" | cut -d'|' -f4)

        YAML+="
  - container: \"${C_NAME}\"
    image: \"${C_IMAGE}\"
    ports: \"${C_PORTS}\"
    status: \"${C_STATUS}\""

        log_ok "${C_NAME}: ${C_IMAGE} → ${C_PORTS:-no ports}"
    done < <(docker ps --format '{{.Names}}|{{.Image}}|{{.Ports}}|{{.Status}}' 2>/dev/null)

    if [ "$FOUND_DOCKER" = false ]; then
        YAML+="
  []  # Docker running, no containers"
        log_info "Docker installed, no running containers"
    fi
else
    YAML+="
  []  # Docker not installed or not running"
    log_info "Docker not installed or not running"
fi

# ── 6. SSL Certificates ──────────────────────────────────────
log_header "SSL Certificates"

YAML+="
ssl_certificates:"

if command -v certbot &>/dev/null; then
    FOUND_CERTS=false

    while IFS= read -r line; do
        CERT_DOMAIN=$(echo "$line" | awk '{print $2}')
        [ -z "$CERT_DOMAIN" ] && continue
        FOUND_CERTS=true

        CERT_PATH="/etc/letsencrypt/live/${CERT_DOMAIN}"
        CERT_EXPIRY=""
        if [ -f "${CERT_PATH}/fullchain.pem" ]; then
            CERT_EXPIRY=$(openssl x509 -enddate -noout -in "${CERT_PATH}/fullchain.pem" 2>/dev/null | cut -d= -f2 || echo "")
        fi

        YAML+="
  - domain: \"${CERT_DOMAIN}\"
    path: \"${CERT_PATH}\"
    expiry: \"${CERT_EXPIRY}\""

        log_ok "${CERT_DOMAIN} → expires: ${CERT_EXPIRY:-unknown}"
    done < <(certbot certificates 2>/dev/null | grep "Certificate Name:" || true)

    if [ "$FOUND_CERTS" = false ]; then
        YAML+="
  []  # Certbot installed, no certificates"
        log_info "Certbot installed, no certificates found"
    fi
else
    YAML+="
  []  # Certbot not installed"
    log_info "Certbot not installed"
fi

# ── 7. Cactus Flasher Board Ports ────────────────────────────
log_header "Cactus Flasher Board Ports"

YAML+="
board_ports:"

# Try to find boards.yaml from cactus-flasher service
CF_DIR=$(systemctl show cactus-flasher -p WorkingDirectory --value 2>/dev/null || echo "")
BOARDS_FILE=""
[ -n "$CF_DIR" ] && [ -f "${CF_DIR}/config/boards.yaml" ] && BOARDS_FILE="${CF_DIR}/config/boards.yaml"

if [ -n "$BOARDS_FILE" ]; then
    YAML+="
  source: \"${BOARDS_FILE}\"
  reserved_ranges:
    webserver: \"8001-8099\"
    ota: \"8201-8299\"
    native_api: \"6001-6099\"
  boards:"

    # Parse boards.yaml — extract board names and IDs
    FOUND_BOARDS=false
    CURRENT_BOARD=""
    while IFS= read -r line; do
        # Match board name (indented key under boards:)
        if echo "$line" | grep -qP '^\s{2}\S+:$'; then
            CURRENT_BOARD=$(echo "$line" | sed 's/://;s/^[[:space:]]*//')
        fi
        # Match id field
        if [ -n "$CURRENT_BOARD" ] && echo "$line" | grep -qP '^\s+id:\s+\d+'; then
            BOARD_ID=$(echo "$line" | grep -oP '\d+')
            FOUND_BOARDS=true

            WEB_PORT=$((8000 + BOARD_ID))
            OTA_PORT=$((8200 + BOARD_ID))
            API_PORT=$((6000 + BOARD_ID))

            YAML+="
    - name: \"${CURRENT_BOARD}\"
      id: ${BOARD_ID}
      webserver: ${WEB_PORT}
      ota: ${OTA_PORT}
      api: ${API_PORT}"

            log_ok "${CURRENT_BOARD} [ID:${BOARD_ID}] → web:${WEB_PORT} ota:${OTA_PORT} api:${API_PORT}"
            CURRENT_BOARD=""
        fi
    done < "$BOARDS_FILE"

    if [ "$FOUND_BOARDS" = false ]; then
        YAML+="
    []  # No boards registered"
        log_info "No boards in boards.yaml"
    fi
else
    YAML+="
  source: null  # Cactus Flasher not found
  reserved_ranges:
    webserver: \"8001-8099\"
    ota: \"8201-8299\"
    native_api: \"6001-6099\"
  boards: []"
    log_info "Cactus Flasher not detected (no boards.yaml)"
fi

# ── 8. Conflicts Detection ───────────────────────────────────
log_header "Conflict Check"

YAML+="
conflicts:"

CONFLICTS_FOUND=false

# Check for duplicate ports
SORTED_PORTS=$(echo "$PORTS_DATA" | grep -v '^$' | cut -d'|' -f1 | sort -n)
DUPES=$(echo "$SORTED_PORTS" | uniq -d)
if [ -n "$DUPES" ]; then
    CONFLICTS_FOUND=true
    for dp in $DUPES; do
        PROCS=$(echo "$PORTS_DATA" | grep "^${dp}|" | cut -d'|' -f3 | tr '\n' ', ' | sed 's/,$//')
        YAML+="
  - type: \"duplicate_port\"
    port: ${dp}
    processes: \"${PROCS}\"
    severity: \"high\""
        log_warn "Port :${dp} used by multiple processes: ${PROCS}"
    done
fi

# Check for Nginx configs pointing to same backend
if [ -d "/etc/nginx/sites-enabled" ]; then
    PROXY_TARGETS=""
    for conf in /etc/nginx/sites-enabled/*; do
        [ -f "$conf" ] || continue
        PP=$(grep -oP 'proxy_pass\s+\K[^;]+' "$conf" | head -1 || true)
        [ -n "$PP" ] && PROXY_TARGETS+="$(basename "$conf")|${PP}\n"
    done
    DUPE_TARGETS=$(echo -e "$PROXY_TARGETS" | grep -v '^$' | cut -d'|' -f2 | sort | uniq -d)
    for dt in $DUPE_TARGETS; do
        [ -z "$dt" ] && continue
        CONFLICTS_FOUND=true
        CONFIGS=$(echo -e "$PROXY_TARGETS" | grep "|${dt}" | cut -d'|' -f1 | tr '\n' ', ' | sed 's/,$//')
        YAML+="
  - type: \"duplicate_proxy\"
    target: \"${dt}\"
    configs: \"${CONFIGS}\"
    severity: \"medium\""
        log_warn "Multiple Nginx configs proxy to ${dt}: ${CONFIGS}"
    done
fi

if [ "$CONFLICTS_FOUND" = false ]; then
    YAML+="
  []  # No conflicts detected"
    log_ok "No conflicts detected"
fi

# ── 9. Available Port Ranges ─────────────────────────────────
log_header "Available Port Ranges"

YAML+="
available_ports:"

# Collect all used ports into a set
USED_PORTS=$(echo "$PORTS_DATA" | grep -v '^$' | cut -d'|' -f1 | sort -nu)

# Check common ranges
check_range() {
    local START=$1 END=$2 NOTE=$3
    local AVAILABLE=true
    for p in $(seq "$START" "$END"); do
        if echo "$USED_PORTS" | grep -q "^${p}$"; then
            AVAILABLE=false
            break
        fi
    done
    if [ "$AVAILABLE" = true ]; then
        YAML+="
  - range: \"${START}-${END}\"
    note: \"${NOTE}\""
        log_ok "${START}-${END}: ${NOTE}"
    fi
}

check_range 3000 3009 "Node.js/React dev servers"
check_range 5000 5009 "Flask/general purpose"
check_range 8100 8199 "Free (between board webserver and OTA ranges)"
check_range 9000 9009 "General purpose app servers"
check_range 9090 9099 "Monitoring/admin tools"

# ── Write file ────────────────────────────────────────────────
echo "$YAML" > "$REGISTRY_FILE"
chmod 644 "$REGISTRY_FILE"

# ── Summary ───────────────────────────────────────────────────
echo ""
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${GREEN}${BOLD}  ✓ Registry saved to ${REGISTRY_FILE}${NC}"
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""
echo -e "  ${BOLD}Quick commands:${NC}"
echo -e "    ${CYAN}vps-portmap --show${NC}       View current registry"
echo -e "    ${CYAN}vps-portmap --check 8080${NC} Check if port is free"
echo -e "    ${CYAN}cat ${REGISTRY_FILE}${NC}     Read raw YAML"
echo ""

# ── Mode: --json output ──────────────────────────────────────
if [ "${1:-}" = "--json" ]; then
    # Simple YAML-to-JSON conversion using Python (available on all Debian)
    python3 -c "
import yaml, json, sys
with open('$REGISTRY_FILE') as f:
    data = yaml.safe_load(f)
print(json.dumps(data, indent=2, default=str))
" 2>/dev/null || echo "Error: python3 + pyyaml needed for JSON output"
fi

# ── Mode: --conflicts only ────────────────────────────────────
if [ "${1:-}" = "--conflicts" ]; then
    if [ "$CONFLICTS_FOUND" = true ]; then
        echo -e "\n${RED}${BOLD}Conflicts found!${NC}"
        # Re-display conflicts
        grep -A3 "type:" "$REGISTRY_FILE" | head -20
        exit 1
    else
        echo -e "\n${GREEN}No conflicts.${NC}"
        exit 0
    fi
fi
